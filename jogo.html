<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harry Potter</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="shortcut icon" href="img/icone.jpg" type="image/x-icon">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Berkshire+Swash&display=swap" rel="stylesheet">
</head>
<body>
   <header>
        <div class="container">
            <div class="logo">
                <a href="index.html#inicio"><img class="logo" src="img/logo.png" alt="Rosto do Harry Potter dourado"></a>
            </div>
            <nav>
                <ul>
                    <li><a href="index.html#inicio">In√≠cio</a></li>
                    <li><a href="index.html#quem">Quem √© HP</a></li>
                    <li><a href="index.html#livros">Livros HP</a></li>
                    <li><a href="index.html#filmes">Filmes HP</a></li>
                    <li><a href="contato.html#contato">Contato</a></li>
                    <li><a href="#jogo">Jogo</a></li>
                </ul>
            </nav>
        </div>    
   </header>

    <!-- Container principal do jogo -->
    <main class="game-main">
        <!-- T√≠tulo do jogo -->
        <div class="game-title">
            <h2>üßô‚Äç‚ôÇ Coletor de Objetos M√°gicos</h2>
            <p>Ajude Dumbledor a coletar objetos m√°gicos enquanto evita os obst√°culos!</p>
        </div>

        <!-- Painel de controle e informa√ß√µes -->
        <div class="game-controls">
            <!-- Placar e informa√ß√µes do jogo -->
            <div class="game-info">
                <div class="score-display">
                    <span class="label">Pontua√ß√£o:</span>
                    <span id="score" class="value">0</span>
                </div>
                <div class="level-display">
                    <span class="label">N√≠vel:</span>
                    <span id="level" class="value">1</span>
                </div>
                <div class="lives-display">
                    <span class="label">Vidas:</span>
                    <span id="lives" class="value">‚ù§‚ù§‚ù§</span>
                </div>
            </div>

            <!-- Bot√µes de controle do jogo -->
            <div class="control-buttons">
                <button id="startBtn" class="btn btn-primary">üéÆ Iniciar</button>
                <button id="pauseBtn" class="btn btn-secondary" disabled>‚è∏ Pausar</button>
                <button id="restartBtn" class="btn btn-accent">üîÑ Reiniciar</button>
            </div>
        </div>

        <!-- √Årea do jogo (onde acontece a a√ß√£o) -->
        <div class="game-area" id="gameArea">
            <!-- Container relativo para posicionamento absoluto dos elementos -->
            <div class="game-container" id="gameContainer">
                <!-- Personagem principal (Harry Potter) -->
                <div class="player" id="player">
                    <span class="player-icon">üßô‚Äç‚ôÇ</span>
                </div>

                <!-- √Årea onde aparecer√£o os objetos colet√°veis -->
                <div class="collectibles-area" id="collectiblesArea">
                    <!-- Os objetos m√°gicos ser√£o criados dinamicamente aqui -->
                </div>

                <!-- √Årea onde aparecer√£o os obst√°culos -->
                <div class="obstacles-area" id="obstaclesArea">
                    <!-- Os obst√°culos ser√£o criados dinamicamente aqui -->
                </div>

                <!-- Efeitos visuais (part√≠culas, explos√µes, etc.) -->
                <div class="effects-area" id="effectsArea">
                    <!-- Efeitos visuais ser√£o criados dinamicamente aqui -->
                </div>
            </div>

            <!-- Tela de game over -->
            <div class="game-over-screen" id="gameOverScreen">
                <div class="game-over-content">
                    <h3>üèÜ Fim de Jogo!</h3>
                    <p>Sua pontua√ß√£o final: <span id="finalScore">0</span></p>
                    <p>N√≠vel alcan√ßado: <span id="finalLevel">1</span></p>
                    <button id="playAgainBtn" class="btn btn-primary">üéÆ Jogar Novamente</button>
                </div>
            </div>

            <!-- Tela de pausa -->
            <div class="pause-screen" id="pauseScreen">
                <div class="pause-content">
                    <h3>‚è∏ Jogo Pausado</h3>
                    <p>Pressione "Continuar" para retomar o jogo</p>
                    <button id="resumeBtn" class="btn btn-primary">‚ñ∂ Continuar</button>
                </div>
            </div>
        </div>

        <!-- Instru√ß√µes do jogo -->
        <div class="game-instructions">
            <h3>üìã Como Jogar:</h3>
            <ul>
                <li>üñ± <strong>Mouse:</strong> Mova o cursor para controlar Dumbledor</li>
                <li>üì± <strong>Touch:</strong> Toque e arraste para mover (dispositivos m√≥veis)</li>
                <li>‚≠ê <strong>Objetivo:</strong> Colete objetos m√°gicos (‚ö°üîÆü™Ñ) para ganhar pontos</li>
                <li>‚ö† <strong>Cuidado:</strong> Evite os obst√°culos (üíÄüêçüï∑) ou perder√° vidas</li>
                <li>üìà <strong>Progress√£o:</strong> A cada n√≠vel, o jogo fica mais r√°pido e desafiador</li>
                <li>‚è∏ <strong>Controles:</strong> Use os bot√µes para pausar, reiniciar ou iniciar o jogo</li>
            </ul>
        </div>
    </main>
<footer>
    <p>2025 - Criado por Robson Cardoso - Todos os Direitos Reservados</p>
</footer>
<script>// ===== VARI√ÅVEIS GLOBAIS DO JOGO =====

// Estado geral do jogo
let gameState = 'stopped'; // Estados poss√≠veis: 'stopped', 'playing', 'paused', 'gameOver'
let gameLoop; // Vari√°vel para armazenar o ID do loop principal do jogo
let lastTime = 0; // Timestamp da √∫ltima execu√ß√£o do loop (para controle de FPS)

// Elementos do DOM que ser√£o manipulados
const gameArea = document.getElementById('gameArea'); // √Årea principal do jogo
const gameContainer = document.getElementById('gameContainer'); // Container dos elementos do jogo
const player = document.getElementById('player'); // Elemento do jogador (Harry Potter)
const collectiblesArea = document.getElementById('collectiblesArea'); // √Årea dos objetos colet√°veis
const obstaclesArea = document.getElementById('obstaclesArea'); // √Årea dos obst√°culos
const effectsArea = document.getElementById('effectsArea'); // √Årea dos efeitos visuais

// Elementos da interface do usu√°rio
const scoreElement = document.getElementById('score'); // Display da pontua√ß√£o
const levelElement = document.getElementById('level'); // Display do n√≠vel
const livesElement = document.getElementById('lives'); // Display das vidas
const gameOverScreen = document.getElementById('gameOverScreen'); // Tela de game over
const pauseScreen = document.getElementById('pauseScreen'); // Tela de pausa
const finalScoreElement = document.getElementById('finalScore'); // Pontua√ß√£o final
const finalLevelElement = document.getElementById('finalLevel'); // N√≠vel final

// Bot√µes de controle
const startBtn = document.getElementById('startBtn'); // Bot√£o de iniciar
const pauseBtn = document.getElementById('pauseBtn'); // Bot√£o de pausar
const restartBtn = document.getElementById('restartBtn'); // Bot√£o de reiniciar
const resumeBtn = document.getElementById('resumeBtn'); // Bot√£o de continuar
const playAgainBtn = document.getElementById('playAgainBtn'); // Bot√£o de jogar novamente

// Vari√°veis de pontua√ß√£o e progresso
let score = 0; // Pontua√ß√£o atual do jogador
let level = 1; // N√≠vel atual do jogo
let lives = 3; // Vidas restantes do jogador
let gameSpeed = 1; // Velocidade base do jogo (aumenta com os n√≠veis)

// Posi√ß√£o do jogador
let playerPosition = { // Objeto para armazenar a posi√ß√£o do jogador
    x: 0, // Posi√ß√£o horizontal (ser√° calculada dinamicamente)
    y: 0  // Posi√ß√£o vertical (ser√° calculada dinamicamente)
};

// Arrays para armazenar os objetos do jogo
let collectibles = []; // Array de objetos colet√°veis ativos
let obstacles = []; // Array de obst√°culos ativos
let effects = []; // Array de efeitos visuais ativos

// Configura√ß√µes do jogo
const gameConfig = {
    // Velocidades de movimento (pixels por frame)
    collectibleSpeed: 2, // Velocidade base dos objetos colet√°veis
    obstacleSpeed: 2.5, // Velocidade base dos obst√°culos
    
    // Frequ√™ncia de spawn (em frames - menor = mais frequente)
    collectibleSpawnRate: 60, // A cada 60 frames (aproximadamente 1 segundo)
    obstacleSpawnRate: 90, // A cada 90 frames (aproximadamente 1.5 segundos)
    
    // Tamanhos dos objetos (para detec√ß√£o de colis√£o)
    playerSize: 40, // Tamanho do jogador
    collectibleSize: 25, // Tamanho dos colet√°veis
    obstacleSize: 30, // Tamanho dos obst√°culos
    
    // Pontua√ß√£o
    pointsPerCollectible: 10, // Pontos ganhos por objeto coletado
    pointsPerLevel: 100, // Pontos necess√°rios para subir de n√≠vel
    
    // Objetos tem√°ticos do Harry Potter
    collectibleTypes: ['‚ö°', 'üîÆ', 'ü™Ñ', 'üìú', 'ü¶â', 'üçØ'], // Objetos m√°gicos colet√°veis
    obstacleTypes: ['üíÄ', 'üêç', 'üï∑', 'üëª', 'ü¶á', 'üî•'] // Obst√°culos perigosos
};

// Contadores para controle de spawn
let collectibleSpawnCounter = 0; // Contador para spawn de colet√°veis
let obstacleSpawnCounter = 0; // Contador para spawn de obst√°culos

// ===== FUN√á√ïES DE INICIALIZA√á√ÉO =====

// Fun√ß√£o principal de inicializa√ß√£o do jogo
function initGame() {
    console.log('Inicializando o jogo...'); // Log para debug
    
    // Configura os event listeners dos bot√µes
    setupEventListeners();
    
    // Configura os controles de movimento do jogador
    setupPlayerControls();
    
    // Configura a posi√ß√£o inicial do jogador
    setupPlayerPosition();
    
    // Configura o menu mobile responsivo
    setupMobileMenu();
    
    console.log('Jogo inicializado com sucesso!'); // Log de confirma√ß√£o
}

// Configura todos os event listeners dos bot√µes
function setupEventListeners() {
    // Bot√£o de iniciar jogo
    startBtn.addEventListener('click', startGame);
    
    // Bot√£o de pausar jogo
    pauseBtn.addEventListener('click', pauseGame);
    
    // Bot√£o de reiniciar jogo
    restartBtn.addEventListener('click', restartGame);
    
    // Bot√£o de continuar (na tela de pausa)
    resumeBtn.addEventListener('click', resumeGame);
    
    // Bot√£o de jogar novamente (na tela de game over)
    playAgainBtn.addEventListener('click', restartGame);
    
    console.log('Event listeners configurados'); // Log para debug
}

// Configura os controles de movimento do jogador
function setupPlayerControls() {
    // Controle por mouse (desktop)
    gameContainer.addEventListener('mousemove', handleMouseMove);
    
    // Controles por touch (mobile)
    gameContainer.addEventListener('touchstart', handleTouchStart, { passive: false });
    gameContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
    
    console.log('Controles do jogador configurados'); // Log para debug
}

// Configura a posi√ß√£o inicial do jogador
function setupPlayerPosition() {
    const containerRect = gameContainer.getBoundingClientRect(); // Obt√©m dimens√µes do container
    
    // Posiciona o jogador no centro horizontal e na parte inferior
    playerPosition.x = containerRect.width / 2; // Centro horizontal
    playerPosition.y = containerRect.height - 60; // Pr√≥ximo √† parte inferior
    
    // Aplica a posi√ß√£o inicial ao elemento do jogador
    updatePlayerPosition();
    
    console.log('Posi√ß√£o inicial do jogador configurada:', playerPosition); // Log para debug
}

// Configura o menu mobile responsivo
function setupMobileMenu() {
    const mobileMenuBtn = document.querySelector('.mobile-menu-btn'); // Bot√£o do menu mobile
    const mainNav = document.querySelector('.main-nav'); // Navega√ß√£o principal
    
    // Adiciona event listener para o bot√£o do menu mobile
    if (mobileMenuBtn && mainNav) {
        mobileMenuBtn.addEventListener('click', function() {
            mainNav.classList.toggle('active'); // Alterna a classe 'active' para mostrar/ocultar menu
            console.log('Menu mobile alternado'); // Log para debug
        });
    }
}

// ===== FUN√á√ïES DE CONTROLE DO JOGO =====

// Inicia o jogo
function startGame() {
    console.log('Iniciando o jogo...'); // Log para debug
    
    // Reseta todas as vari√°veis para o estado inicial
    resetGameVariables();
    
    // Atualiza a interface do usu√°rio
    updateUI();
    
    // Oculta telas de sobreposi√ß√£o
    hideOverlayScreens();
    
    // Configura os bot√µes para o estado de jogo ativo
    setGameActiveButtons();
    
    // Adiciona classe CSS para estado de jogo ativo
    gameArea.classList.add('game-active');
    
    // Muda o estado do jogo para 'playing'
    gameState = 'playing';
    
    // Inicia o loop principal do jogo
    startGameLoop();
    
    console.log('Jogo iniciado com sucesso!'); // Log de confirma√ß√£o
}

// Pausa o jogo
function pauseGame() {
    if (gameState !== 'playing') return; // S√≥ pausa se estiver jogando
    
    console.log('Pausando o jogo...'); // Log para debug
    
    // Muda o estado para pausado
    gameState = 'paused';
    
    // Para o loop do jogo
    stopGameLoop();
    
    // Mostra a tela de pausa
    showPauseScreen();
    
    // Atualiza os bot√µes
    setPausedButtons();
    
    // Adiciona classe CSS para estado pausado
    gameArea.classList.add('game-paused');
    
    console.log('Jogo pausado'); // Log de confirma√ß√£o
}

// Retoma o jogo ap√≥s pausa
function resumeGame() {
    if (gameState !== 'paused') return; // S√≥ retoma se estiver pausado
    
    console.log('Retomando o jogo...'); // Log para debug
    
    // Muda o estado para jogando
    gameState = 'playing';
    
    // Oculta a tela de pausa
    hidePauseScreen();
    
    // Atualiza os bot√µes
    setGameActiveButtons();
    
    // Remove classe CSS de pausado
    gameArea.classList.remove('game-paused');
    
    // Reinicia o loop do jogo
    startGameLoop();
    
    console.log('Jogo retomado'); // Log de confirma√ß√£o
}

// Reinicia o jogo completamente
function restartGame() {
    console.log('Reiniciando o jogo...'); // Log para debug
    
    // Para o loop atual se estiver rodando
    stopGameLoop();
    
    // Limpa todos os objetos da tela
    clearAllGameObjects();
    
    // Remove todas as classes de estado
    gameArea.classList.remove('game-active', 'game-paused', 'game-ended');
    
    // Inicia um novo jogo
    startGame();
    
    console.log('Jogo reiniciado'); // Log de confirma√ß√£o
}

// Termina o jogo (game over)
function endGame() {
    console.log('Terminando o jogo...'); // Log para debug
    
    // Muda o estado para game over
    gameState = 'gameOver';
    
    // Para o loop do jogo
    stopGameLoop();
    
    // Atualiza a pontua√ß√£o final na tela de game over
    finalScoreElement.textContent = score;
    finalLevelElement.textContent = level;
    
    // Mostra a tela de game over
    showGameOverScreen();
    
    // Atualiza os bot√µes
    setGameOverButtons();
    
    // Adiciona classe CSS para estado de fim de jogo
    gameArea.classList.add('game-ended');
    gameArea.classList.remove('game-active', 'game-paused');
    
    console.log('Jogo terminado. Pontua√ß√£o final:', score); // Log de confirma√ß√£o
}

// ===== FUN√á√ïES DO LOOP PRINCIPAL =====

// Inicia o loop principal do jogo
function startGameLoop() {
    lastTime = performance.now(); // Registra o tempo inicial
    gameLoop = requestAnimationFrame(gameLoopFunction); // Inicia o loop
    console.log('Loop do jogo iniciado'); // Log para debug
}

// Para o loop principal do jogo
function stopGameLoop() {
    if (gameLoop) {
        cancelAnimationFrame(gameLoop); // Cancela o loop
        gameLoop = null; // Limpa a refer√™ncia
        console.log('Loop do jogo parado'); // Log para debug
    }
}

// Fun√ß√£o principal do loop do jogo (executada a cada frame)
function gameLoopFunction(currentTime) {
    // Calcula o tempo decorrido desde o √∫ltimo frame
    const deltaTime = currentTime - lastTime;
    lastTime = currentTime;
    
    // S√≥ executa se o jogo estiver ativo
    if (gameState === 'playing') {
        // Atualiza todos os elementos do jogo
        updateGame(deltaTime);
        
        // Renderiza todos os elementos na tela
        renderGame();
    }
    
    // Agenda o pr√≥ximo frame se o jogo ainda estiver rodando
    if (gameState === 'playing') {
        gameLoop = requestAnimationFrame(gameLoopFunction);
    }
}

// Atualiza toda a l√≥gica do jogo
function updateGame(deltaTime) {
    // Atualiza contadores de spawn
    updateSpawnCounters();
    
    // Cria novos objetos colet√°veis
    spawnCollectibles();
    
    // Cria novos obst√°culos
    spawnObstacles();
    
    // Move todos os objetos colet√°veis
    updateCollectibles();
    
    // Move todos os obst√°culos
    updateObstacles();
    
    // Atualiza efeitos visuais
    updateEffects();
    
    // Verifica colis√µes entre jogador e objetos
    checkCollisions();
    
    // Verifica se deve subir de n√≠vel
    checkLevelUp();
    
    // Remove objetos que sa√≠ram da tela
    cleanupObjects();
}

// Renderiza todos os elementos visuais
function renderGame() {
    // Atualiza a posi√ß√£o visual do jogador
    updatePlayerPosition();
    
    // Atualiza a interface do usu√°rio
    updateUI();
}

// ===== FUN√á√ïES DE MOVIMENTO DO JOGADOR =====

// Manipula movimento do mouse
function handleMouseMove(event) {
    if (gameState !== 'playing') return; // S√≥ move se estiver jogando
    
    const rect = gameContainer.getBoundingClientRect(); // Obt√©m posi√ß√£o do container
    
    // Calcula nova posi√ß√£o baseada na posi√ß√£o do mouse
    playerPosition.x = event.clientX - rect.left;
    playerPosition.y = event.clientY - rect.top;
    
    // Garante que o jogador n√£o saia dos limites
    constrainPlayerPosition();
}

// Manipula in√≠cio do toque (touch)
function handleTouchStart(event) {
    event.preventDefault(); // Previne comportamento padr√£o do touch
    
    if (gameState !== 'playing') return; // S√≥ move se estiver jogando
    
    const touch = event.touches[0]; // Obt√©m o primeiro toque
    const rect = gameContainer.getBoundingClientRect(); // Obt√©m posi√ß√£o do container
    
    // Calcula nova posi√ß√£o baseada na posi√ß√£o do toque
    playerPosition.x = touch.clientX - rect.left;
    playerPosition.y = touch.clientY - rect.top;
    
    // Garante que o jogador n√£o saia dos limites
    constrainPlayerPosition();
}

// Manipula movimento do toque (touch)
function handleTouchMove(event) {
    event.preventDefault(); // Previne comportamento padr√£o do touch
    
    if (gameState !== 'playing') return; // S√≥ move se estiver jogando
    
    const touch = event.touches[0]; // Obt√©m o primeiro toque
    const rect = gameContainer.getBoundingClientRect(); // Obt√©m posi√ß√£o do container
    
    // Calcula nova posi√ß√£o baseada na posi√ß√£o do toque
    playerPosition.x = touch.clientX - rect.left;
    playerPosition.y = touch.clientY - rect.top;
    
    // Garante que o jogador n√£o saia dos limites
    constrainPlayerPosition();
}

// Garante que o jogador n√£o saia dos limites da √°rea do jogo
function constrainPlayerPosition() {
    const containerRect = gameContainer.getBoundingClientRect(); // Obt√©m dimens√µes do container
    const playerSize = gameConfig.playerSize; // Tamanho do jogador
    
    // Limita posi√ß√£o horizontal
    playerPosition.x = Math.max(playerSize / 2, Math.min(containerRect.width - playerSize / 2, playerPosition.x));
    
    // Limita posi√ß√£o vertical
    playerPosition.y = Math.max(playerSize / 2, Math.min(containerRect.height - playerSize / 2, playerPosition.y));
}

// Atualiza a posi√ß√£o visual do jogador na tela
function updatePlayerPosition() {
    // Aplica a posi√ß√£o calculada ao elemento do jogador
    player.style.left = (playerPosition.x - gameConfig.playerSize / 2) + 'px';
    player.style.bottom = (gameContainer.getBoundingClientRect().height - playerPosition.y - gameConfig.playerSize / 2) + 'px';
}

// ===== FUN√á√ïES DE SPAWN DE OBJETOS =====

// Atualiza contadores de spawn
function updateSpawnCounters() {
    collectibleSpawnCounter++; // Incrementa contador de colet√°veis
    obstacleSpawnCounter++; // Incrementa contador de obst√°culos
}

// Cria novos objetos colet√°veis
function spawnCollectibles() {
    // Verifica se √© hora de criar um novo colet√°vel
    if (collectibleSpawnCounter >= gameConfig.collectibleSpawnRate / gameSpeed) {
        createCollectible(); // Cria o colet√°vel
        collectibleSpawnCounter = 0; // Reseta o contador
    }
}

// Cria novos obst√°culos
function spawnObstacles() {
    // Verifica se √© hora de criar um novo obst√°culo
    if (obstacleSpawnCounter >= gameConfig.obstacleSpawnRate / gameSpeed) {
        createObstacle(); // Cria o obst√°culo
        obstacleSpawnCounter = 0; // Reseta o contador
    }
}

// Cria um objeto colet√°vel
function createCollectible() {
    const containerRect = gameContainer.getBoundingClientRect(); // Obt√©m dimens√µes do container
    
    // Cria objeto colet√°vel com propriedades
    const collectible = {
        id: Date.now() + Math.random(), // ID √∫nico
        x: Math.random() * (containerRect.width - gameConfig.collectibleSize), // Posi√ß√£o X aleat√≥ria
        y: -gameConfig.collectibleSize, // Come√ßa acima da tela
        type: gameConfig.collectibleTypes[Math.floor(Math.random() * gameConfig.collectibleTypes.length)], // Tipo aleat√≥rio
        element: null // Refer√™ncia ao elemento DOM (ser√° criada)
    };
    
    // Cria elemento DOM para o colet√°vel
    collectible.element = document.createElement('div');
    collectible.element.className = 'collectible'; // Aplica classe CSS
    collectible.element.textContent = collectible.type; // Define o emoji
    collectible.element.style.left = collectible.x + 'px'; // Posi√ß√£o horizontal
    collectible.element.style.top = collectible.y + 'px'; // Posi√ß√£o vertical
    
    // Adiciona o elemento √† √°rea de colet√°veis
    collectiblesArea.appendChild(collectible.element);
    
    // Adiciona o colet√°vel ao array
    collectibles.push(collectible);
    
    console.log('Colet√°vel criado:', collectible.type); // Log para debug
}

// Cria um obst√°culo
function createObstacle() {
    const containerRect = gameContainer.getBoundingClientRect(); // Obt√©m dimens√µes do container
    
    // Cria objeto obst√°culo com propriedades
    const obstacle = {
        id: Date.now() + Math.random(), // ID √∫nico
        x: Math.random() * (containerRect.width - gameConfig.obstacleSize), // Posi√ß√£o X aleat√≥ria
        y: -gameConfig.obstacleSize, // Come√ßa acima da tela
        type: gameConfig.obstacleTypes[Math.floor(Math.random() * gameConfig.obstacleTypes.length)], // Tipo aleat√≥rio
        element: null // Refer√™ncia ao elemento DOM (ser√° criada)
    };
    
    // Cria elemento DOM para o obst√°culo
    obstacle.element = document.createElement('div');
    obstacle.element.className = 'obstacle'; // Aplica classe CSS
    obstacle.element.textContent = obstacle.type; // Define o emoji
    obstacle.element.style.left = obstacle.x + 'px'; // Posi√ß√£o horizontal
    obstacle.element.style.top = obstacle.y + 'px'; // Posi√ß√£o vertical
    
    // Adiciona o elemento √† √°rea de obst√°culos
    obstaclesArea.appendChild(obstacle.element);
    
    // Adiciona o obst√°culo ao array
    obstacles.push(obstacle);
    
    console.log('Obst√°culo criado:', obstacle.type); // Log para debug
}

// ===== FUN√á√ïES DE ATUALIZA√á√ÉO DE OBJETOS =====

// Atualiza todos os objetos colet√°veis
function updateCollectibles() {
    // Itera sobre todos os colet√°veis
    for (let i = collectibles.length - 1; i >= 0; i--) {
        const collectible = collectibles[i]; // Obt√©m o colet√°vel atual
        
        // Move o colet√°vel para baixo
        collectible.y += gameConfig.collectibleSpeed * gameSpeed;
        
        // Atualiza posi√ß√£o visual
        collectible.element.style.top = collectible.y + 'px';
        
        // Remove colet√°vel se saiu da tela
        if (collectible.y > gameContainer.getBoundingClientRect().height) {
            removeCollectible(i); // Remove da tela e do array
        }
    }
}

// Atualiza todos os obst√°culos
function updateObstacles() {
    // Itera sobre todos os obst√°culos
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i]; // Obt√©m o obst√°culo atual
        
        // Move o obst√°culo para baixo
        obstacle.y += gameConfig.obstacleSpeed * gameSpeed;
        
        // Atualiza posi√ß√£o visual
        obstacle.element.style.top = obstacle.y + 'px';
        
        // Remove obst√°culo se saiu da tela
        if (obstacle.y > gameContainer.getBoundingClientRect().height) {
            removeObstacle(i); // Remove da tela e do array
        }
    }
}

// Atualiza todos os efeitos visuais
function updateEffects() {
    // Itera sobre todos os efeitos
    for (let i = effects.length - 1; i >= 0; i--) {
        const effect = effects[i]; // Obt√©m o efeito atual
        
        // Reduz o tempo de vida do efeito
        effect.lifetime--;
        
        // Remove efeito se o tempo acabou
        if (effect.lifetime <= 0) {
            removeEffect(i); // Remove da tela e do array
        }
    }
}

// ===== FUN√á√ïES DE DETEC√á√ÉO DE COLIS√ÉO =====

// Verifica todas as colis√µes
function checkCollisions() {
    checkCollectibleCollisions(); // Verifica colis√µes com colet√°veis
    checkObstacleCollisions(); // Verifica colis√µes com obst√°culos
}

// Verifica colis√µes com objetos colet√°veis
function checkCollectibleCollisions() {
    // Itera sobre todos os colet√°veis
    for (let i = collectibles.length - 1; i >= 0; i--) {
        const collectible = collectibles[i]; // Obt√©m o colet√°vel atual
        
        // Verifica se h√° colis√£o com o jogador
        if (isColliding(playerPosition, collectible, gameConfig.playerSize, gameConfig.collectibleSize)) {
            // Colis√£o detectada!
            collectCollectible(i); // Processa a coleta
        }
    }
}

// Verifica colis√µes com obst√°culos
function checkObstacleCollisions() {
    // Itera sobre todos os obst√°culos
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i]; // Obt√©m o obst√°culo atual
        
        // Verifica se h√° colis√£o com o jogador
        if (isColliding(playerPosition, obstacle, gameConfig.playerSize, gameConfig.obstacleSize)) {
            // Colis√£o detectada!
            hitObstacle(i); // Processa a colis√£o
        }
    }
}

// Fun√ß√£o para detectar colis√£o entre dois objetos circulares
function isColliding(obj1, obj2, size1, size2) {
    // Calcula a dist√¢ncia entre os centros dos objetos
    const dx = obj1.x - (obj2.x + size2 / 2); // Diferen√ßa horizontal
    const dy = obj1.y - (obj2.y + size2 / 2); // Diferen√ßa vertical
    const distance = Math.sqrt(dx * dx + dy * dy); // Dist√¢ncia euclidiana
    
    // Calcula a dist√¢ncia m√≠nima para colis√£o
    const minDistance = (size1 + size2) / 2;
    
    // Retorna true se h√° colis√£o
    return distance < minDistance;
}

// ===== FUN√á√ïES DE PROCESSAMENTO DE COLIS√ïES =====

// Processa a coleta de um objeto colet√°vel
function collectCollectible(index) {
    const collectible = collectibles[index]; // Obt√©m o colet√°vel
    
    // Aumenta a pontua√ß√£o
    score += gameConfig.pointsPerCollectible;
    
    // Cria efeito visual de coleta
    createCollectEffect(collectible.x, collectible.y, collectible.type);
    
    // Remove o colet√°vel
    removeCollectible(index);
    
    // Atualiza a interface
    updateUI();
    
    console.log('Colet√°vel coletado! Pontua√ß√£o:', score); // Log para debug
}

// Processa a colis√£o com um obst√°culo
function hitObstacle(index) {
    const obstacle = obstacles[index]; // Obt√©m o obst√°culo
    
    // Reduz uma vida
    lives--;
    
    // Cria efeito visual de colis√£o
    createHitEffect(obstacle.x, obstacle.y);
    
    // Remove o obst√°culo
    removeObstacle(index);
    
    // Adiciona anima√ß√£o de colis√£o ao jogador
    player.classList.add('collision-animation');
    setTimeout(() => {
        player.classList.remove('collision-animation'); // Remove ap√≥s a anima√ß√£o
    }, 600);
    
    // Atualiza a interface
    updateUI();
    
    // Verifica se o jogo acabou
    if (lives <= 0) {
        endGame(); // Termina o jogo se n√£o h√° mais vidas
    }
    
    console.log('Obst√°culo atingido! Vidas restantes:', lives); // Log para debug
}

// ===== FUN√á√ïES DE EFEITOS VISUAIS =====

// Cria efeito visual de coleta
function createCollectEffect(x, y, type) {
    // Cria elemento do efeito
    const effect = document.createElement('div');
    effect.className = 'collect-effect'; // Aplica classe CSS
    effect.textContent = '+' + gameConfig.pointsPerCollectible; // Mostra pontos ganhos
    effect.style.position = 'absolute'; // Posicionamento absoluto
    effect.style.left = x + 'px'; // Posi√ß√£o horizontal
    effect.style.top = y + 'px'; // Posi√ß√£o vertical
    effect.style.color = '#ffd700'; // Cor dourada
    effect.style.fontWeight = 'bold'; // Negrito
    effect.style.fontSize = '1.2rem'; // Tamanho da fonte
    effect.style.pointerEvents = 'none'; // N√£o interfere com cliques
    effect.style.zIndex = '15'; // Camada superior
    
    // Adiciona √† √°rea de efeitos
    effectsArea.appendChild(effect);
    
    // Adiciona anima√ß√£o
    effect.classList.add('collect-animation');
    
    // Remove ap√≥s a anima√ß√£o
    setTimeout(() => {
        if (effect.parentNode) {
            effectsArea.removeChild(effect);
        }
    }, 500);
    
    console.log('Efeito de coleta criado'); // Log para debug
}

// Cria efeito visual de colis√£o
function createHitEffect(x, y) {
    // Cria elemento do efeito
    const effect = document.createElement('div');
    effect.className = 'hit-effect'; // Aplica classe CSS
    effect.textContent = 'üí•'; // Emoji de explos√£o
    effect.style.position = 'absolute'; // Posicionamento absoluto
    effect.style.left = x + 'px'; // Posi√ß√£o horizontal
    effect.style.top = y + 'px'; // Posi√ß√£o vertical
    effect.style.fontSize = '2rem'; // Tamanho grande
    effect.style.pointerEvents = 'none'; // N√£o interfere com cliques
    effect.style.zIndex = '15'; // Camada superior
    
    // Adiciona √† √°rea de efeitos
    effectsArea.appendChild(effect);
    
    // Adiciona anima√ß√£o
    effect.classList.add('collision-animation');
    
    // Remove ap√≥s a anima√ß√£o
    setTimeout(() => {
        if (effect.parentNode) {
            effectsArea.removeChild(effect);
        }
    }, 600);
    
    console.log('Efeito de colis√£o criado'); // Log para debug
}

// ===== FUN√á√ïES DE REMO√á√ÉO DE OBJETOS =====

// Remove um colet√°vel espec√≠fico
function removeCollectible(index) {
    const collectible = collectibles[index]; // Obt√©m o colet√°vel
    
    // Remove elemento do DOM
    if (collectible.element && collectible.element.parentNode) {
        collectiblesArea.removeChild(collectible.element);
    }
    
    // Remove do array
    collectibles.splice(index, 1);
}

// Remove um obst√°culo espec√≠fico
function removeObstacle(index) {
    const obstacle = obstacles[index]; // Obt√©m o obst√°culo
    
    // Remove elemento do DOM
    if (obstacle.element && obstacle.element.parentNode) {
        obstaclesArea.removeChild(obstacle.element);
    }
    
    // Remove do array
    obstacles.splice(index, 1);
}

// Remove um efeito espec√≠fico
function removeEffect(index) {
    const effect = effects[index]; // Obt√©m o efeito
    
    // Remove elemento do DOM
    if (effect.element && effect.element.parentNode) {
        effectsArea.removeChild(effect.element);
    }
    
    // Remove do array
    effects.splice(index, 1);
}

// Remove objetos que sa√≠ram da tela
function cleanupObjects() {
    const containerHeight = gameContainer.getBoundingClientRect().height; // Altura do container
    
    // Limpa colet√°veis que sa√≠ram da tela
    for (let i = collectibles.length - 1; i >= 0; i--) {
        if (collectibles[i].y > containerHeight + 50) { // 50px de margem
            removeCollectible(i);
        }
    }
    
    // Limpa obst√°culos que sa√≠ram da tela
    for (let i = obstacles.length - 1; i >= 0; i--) {
        if (obstacles[i].y > containerHeight + 50) { // 50px de margem
            removeObstacle(i);
        }
    }
}

// Limpa todos os objetos do jogo
function clearAllGameObjects() {
    // Remove todos os colet√°veis
    while (collectibles.length > 0) {
        removeCollectible(0);
    }
    
    // Remove todos os obst√°culos
    while (obstacles.length > 0) {
        removeObstacle(0);
    }
    
    // Remove todos os efeitos
    while (effects.length > 0) {
        removeEffect(0);
    }
    
    console.log('Todos os objetos do jogo foram limpos'); // Log para debug
}

// ===== FUN√á√ïES DE PROGRESS√ÉO DO JOGO =====

// Verifica se deve subir de n√≠vel
function checkLevelUp() {
    const requiredScore = level * gameConfig.pointsPerLevel; // Pontua√ß√£o necess√°ria para o pr√≥ximo n√≠vel
    
    // Verifica se atingiu a pontua√ß√£o necess√°ria
    if (score >= requiredScore) {
        levelUp(); // Sobe de n√≠vel
    }
}

// Sobe de n√≠vel
function levelUp() {
    level++; // Incrementa o n√≠vel
    gameSpeed += 0.2; // Aumenta a velocidade do jogo
    
    // Cria efeito visual de level up
    createLevelUpEffect();
    
    // Atualiza a interface
    updateUI();
    
    console.log('Level up! N√≠vel atual:', level, 'Velocidade:', gameSpeed); // Log para debug
}

// Cria efeito visual de level up
function createLevelUpEffect() {
    // Cria elemento do efeito
    const effect = document.createElement('div');
    effect.textContent = 'N√çVEL ' + level + '!'; // Texto do level up
    effect.style.position = 'absolute'; // Posicionamento absoluto
    effect.style.top = '50%'; // Centro vertical
    effect.style.left = '50%'; // Centro horizontal
    effect.style.transform = 'translate(-50%, -50%)'; // Centraliza perfeitamente
    effect.style.color = '#ffd700'; // Cor dourada
    effect.style.fontSize = '2rem'; // Tamanho grande
    effect.style.fontWeight = 'bold'; // Negrito
    effect.style.textShadow = '2px 2px 4px rgba(0,0,0,0.8)'; // Sombra do texto
    effect.style.pointerEvents = 'none'; // N√£o interfere com cliques
    effect.style.zIndex = '20'; // Camada muito superior
    effect.style.animation = 'fadeInUp 1s ease-out'; // Anima√ß√£o de entrada
    
    // Adiciona √† √°rea de efeitos
    effectsArea.appendChild(effect);
    
    // Remove ap√≥s 2 segundos
    setTimeout(() => {
        if (effect.parentNode) {
            effectsArea.removeChild(effect);
        }
    }, 2000);
    
    console.log('Efeito de level up criado'); // Log para debug
}

// ===== FUN√á√ïES DE INTERFACE DO USU√ÅRIO =====

// Atualiza todos os elementos da interface
function updateUI() {
    updateScore(); // Atualiza pontua√ß√£o
    updateLevel(); // Atualiza n√≠vel
    updateLives(); // Atualiza vidas
}

// Atualiza display da pontua√ß√£o
function updateScore() {
    scoreElement.textContent = score; // Define o texto da pontua√ß√£o
}

// Atualiza display do n√≠vel
function updateLevel() {
    levelElement.textContent = level; // Define o texto do n√≠vel
}

// Atualiza display das vidas
function updateLives() {
    let livesText = ''; // String para armazenar os cora√ß√µes
    
    // Adiciona cora√ß√µes baseado no n√∫mero de vidas
    for (let i = 0; i < lives; i++) {
        livesText += '‚ù§'; // Adiciona cora√ß√£o vermelho
    }
    
    // Adiciona cora√ß√µes vazios para vidas perdidas
    for (let i = lives; i < 3; i++) {
        livesText += 'üñ§'; // Adiciona cora√ß√£o preto (vazio)
    }
    
    livesElement.textContent = livesText; // Define o texto das vidas
}

// ===== FUN√á√ïES DE CONTROLE DE TELAS =====

// Oculta todas as telas de sobreposi√ß√£o
function hideOverlayScreens() {
    gameOverScreen.style.display = 'none'; // Oculta tela de game over
    pauseScreen.style.display = 'none'; // Oculta tela de pausa
}

// Mostra a tela de game over
function showGameOverScreen() {
    gameOverScreen.style.display = 'flex'; // Mostra tela de game over
}

// Mostra a tela de pausa
function showPauseScreen() {
    pauseScreen.style.display = 'flex'; // Mostra tela de pausa
}

// Oculta a tela de pausa
function hidePauseScreen() {
    pauseScreen.style.display = 'none'; // Oculta tela de pausa
}

// ===== FUN√á√ïES DE CONTROLE DE BOT√ïES =====

// Configura bot√µes para estado de jogo ativo
function setGameActiveButtons() {
    startBtn.disabled = true; // Desabilita bot√£o de iniciar
    pauseBtn.disabled = false; // Habilita bot√£o de pausar
    restartBtn.disabled = false; // Habilita bot√£o de reiniciar
}

// Configura bot√µes para estado pausado
function setPausedButtons() {
    startBtn.disabled = true; // Desabilita bot√£o de iniciar
    pauseBtn.disabled = true; // Desabilita bot√£o de pausar
    restartBtn.disabled = false; // Habilita bot√£o de reiniciar
}

// Configura bot√µes para estado de game over
function setGameOverButtons() {
    startBtn.disabled = false; // Habilita bot√£o de iniciar
    pauseBtn.disabled = true; // Desabilita bot√£o de pausar
    restartBtn.disabled = false; // Habilita bot√£o de reiniciar
}

// ===== FUN√á√ïES DE RESET =====

// Reseta todas as vari√°veis do jogo para o estado inicial
function resetGameVariables() {
    score = 0; // Reseta pontua√ß√£o
    level = 1; // Reseta n√≠vel
    lives = 3; // Reseta vidas
    gameSpeed = 1; // Reseta velocidade
    collectibleSpawnCounter = 0; // Reseta contador de spawn de colet√°veis
    obstacleSpawnCounter = 0; // Reseta contador de spawn de obst√°culos
    
    // Limpa arrays de objetos
    collectibles = [];
    obstacles = [];
    effects = [];
    
    console.log('Vari√°veis do jogo resetadas'); // Log para debug
}

// ===== INICIALIZA√á√ÉO =====

// Aguarda o carregamento completo da p√°gina antes de inicializar
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM carregado, inicializando jogo...'); // Log para debug
    initGame(); // Chama a fun√ß√£o de inicializa√ß√£o
});

// Adiciona listener para redimensionamento da janela
window.addEventListener('resize', function() {
    // Reconfigura a posi√ß√£o do jogador quando a janela √© redimensionada
    setupPlayerPosition();
    console.log('Janela redimensionada, posi√ß√£o do jogador reconfigurada'); // Log para debug
});

// Log final de carregamento do script
console.log('Script do jogo carregado com sucesso!'); // Log de confirma√ß√£o</script>        
</body>
</html>